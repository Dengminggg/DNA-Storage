首先，它将二进制文件预处理为一系列具有一定长度的不重叠段。接下来，它迭代两个计算步骤：Luby 变换和筛选。 Luby 变换为喷泉码奠定了基础。基本上，它通过使用特殊分布（图 S7）从文件中选择随机段子集并将它们按位添加到二进制字段下，将数据打包成任何所需数量的短消息，称为 droplets。液滴包含两条信息：一个包含添加过程结果的数据有效负载部分和一个短的、固定长度的种子。该种子对应于液滴创建期间变换的随机数生成器的状态，并允许解码器算法推断液滴中片段的身份。理论上，只要累积的液滴大小略大于原始文件的大小，就可以使用高效算法通过收集液滴的任何子集来反转 Luby 变换。

.我们将输入 tarball 拆分为 67,088 个 32 字节的段，并迭代 DNA Fountain 的步骤以创建有效的寡核苷酸。

每个液滴为 38 个字节（304 位）：4 个字节的随机数生成器种子，32 个字节用于数据有效负载，2 个字节用于 RS 纠错码，以在低覆盖率条件下拒绝错误的寡核苷酸。有了这个种子长度，我们的策略支持高达 500 MB (12) 的编码文件。DNA 寡核苷酸的长度为 304/2 = 152 个核苷酸 (nt)。

-----------------------------------------------------------------------------------------------------------

在预处理步骤中，我们首先将感兴趣的文件打包成单个磁带存档 (tar) 文件，然后使用标准无损算法（例如 gzip）对其进行压缩。除了减小 tar 文件大小的明显优势外，压缩还增加了输入文件每一位的熵并减少了局部相关性，这对于筛选步骤很重要。然后，该算法将压缩文件逻辑划分为长度为 L 位的非重叠段，这是用户定义的参数。我们在实验中使用 L = 256 位（32 字节），因为这个数字与标准计算环境兼容，并且生成的寡核苷酸长度在制造商的限制范围内。

我们用种子初始化一个伪随机数生成器（PRNG），种子是根据 1.3.2 节中解释的数学规则选择的。

该算法决定 d，即要打包在液滴中的段数。为此，该算法使用 PRNG 从一个特殊的分布函数中抽取一个随机数，称为鲁棒孤子概率分布。简而言之，稳健的孤子分布函数是双峰的，并确保大多数液滴是用少量输入段或固定的中间段数创建的。这种数学特性对于解码过程至关重要。 1.3.3 节详细介绍了这种分布。

该算法再次使用 PRNG 从使用均匀分布的段集合中绘制 d 段而不进行替换。

该算法对段执行按位异或运算（按位加法模 2）。

该算法附加一个固定长度索引，指定种子的二进制表示。例如，如果种子为3，固定索引长度为2位，则输出微滴将为110001。在实践中，为了与标准计算环境兼容，我们使用了32位（4字节）索引。

用户可以选择使用在整个液滴上计算的常规纠错码。在我们的实验中，我们在GF（256）上添加了两个字节的Reed-Solomon，以提高我们设计的稳健性。

